import pandas as pd
import numpy as np
from ta.momentum import RSIIndicator
from ta.trend import MACD

class FeatureEngineer:
    def __init__(self):
        pass

    def add_technical_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Add RSI, MACD, and basic Supply/Demand zone proximity features.
        """
        if df is None or df.empty:
            return df
            
        # Ensure we work on a copy to avoid SettingWithCopyWarning
        df = df.copy()

        # 1. RSI (14)
        rsi_indicator = RSIIndicator(close=df["close"], window=14)
        df["rsi"] = rsi_indicator.rsi()

        # 2. MACD
        macd_indicator = MACD(close=df["close"])
        df["macd"] = macd_indicator.macd()
        df["macd_signal"] = macd_indicator.macd_signal()
        df["macd_diff"] = macd_indicator.macd_diff()

        # 3. Supply and Demand Zones (Simplified)
        # We detect local min/max as proxy for zones
        df = self._add_sd_zones(df)
        
        # 4. Returns (for target creation during training)
        df["returns"] = df["close"].pct_change()
        
        # Drop NaN values generated by windows
        df.dropna(inplace=True)

        return df

    def _add_sd_zones(self, df: pd.DataFrame, window: int = 20) -> pd.DataFrame:
        """
        Calculate distance to nearest 'Supply' (local max) and 'Demand' (local min) zones.
        """
        # Fractal/Pivot Highs and Lows
        df["pivot_high"] = df["high"].rolling(window=window, center=True).max()
        df["pivot_low"] = df["low"].rolling(window=window, center=True).min()

        # Identify mostly static pivot levels (zones)
        # For scalping, we just want distance to the recent significant high/low
        
        # Fill forward to carry the last known pivot
        df["last_supply"] = df["pivot_high"].ffill()
        df["last_demand"] = df["pivot_low"].ffill()

        # Calculate distances (features for the model)
        # Normalized by price to be scale-invariant
        df["dist_to_supply"] = (df["last_supply"] - df["close"]) / df["close"]
        df["dist_to_demand"] = (df["close"] - df["last_demand"]) / df["close"]
        
        # Handle cases where price exceeds recent pivots (breakouts)
        df["dist_to_supply"] = df["dist_to_supply"].fillna(0)
        df["dist_to_demand"] = df["dist_to_demand"].fillna(0)
        
        return df
